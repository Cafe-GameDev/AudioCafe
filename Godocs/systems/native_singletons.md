# Singletons Nativos do Godot

## AudioServer
O AudioServer é a interface de servidor de áudio de baixo nível do Godot, responsável por gerenciar a criação e reprodução de áudio. Ele permite criar Samples (dados de áudio manipuláveis em memória) e tocar estes samples em voices (canais de áudio). O AudioServer fornece métodos para criar samples (sample_create), definir dados brutos de áudio, configurar loops e taxas de amostragem, bem como controlar propriedades globais de volume e efeitos. Por exemplo, é possível controlar a escala de volume global de streams e vozes com `set_stream_global_volume_scale` e `set_fx_global_volume_scale`. Vozes de reprodução (tipo voice) são criadas com `voice_create`, e permitem tocar um sample usando `voice_play`. As vozes suportam pós-processamentos como chorus, filtro, pan (balanceamento estéreo) e reverb, ajustáveis em tempo real (métodos `voice_set_*` e obtenção via `voice_get_*`). Em resumo, o AudioServer fornece todas as funcionalidades para manipular áudio no nível mais baixo do Godot, incluindo criação de fontes de áudio, reprodução em vozes e controle de efeitos globais.

## Crypto
A classe Crypto disponibiliza funcionalidades avançadas de criptografia no Godot. Ela permite operações como geração de chaves RSA, criptografia e descriptografia de dados, assinaturas digitais, verificação de assinaturas e geração de certificados X.509 autoassinados. Por exemplo, `generate_rsa(4096)` cria uma `CryptoKey` RSA de 4096 bits, que pode ser usada para criptografia ou para gerar certificados. O método `generate_self_signed_certificate` gera um certificado X.509 usando uma chave RSA e dados de issuer name. Os dados podem ser criptografados com `encrypt(key, plaintext)` e depois descriptografados com `decrypt(key, ciphertext)`. Além disso, existem métodos `sign(hash_type, hash, key)` e `verify(hash_type, hash, signature, key)` para assinar digitalmente hashes e verificar assinaturas. Funções utilitárias adicionais incluem geração de bytes aleatórios criptograficamente seguros (`generate_random_bytes`) e cálculo de HMAC (`hmac_digest`). Em suma, Crypto oferece as principais operações de criptografia (criptografia simétrica/assimétrica, hashes, HMAC e certificados) necessárias para aplicações seguras no Godot.

## DisplayServer
O DisplayServer é a interface de servidor responsável pelo gerenciamento de janelas (windows) e telas (monitores) de forma de baixo nível no Godot. Ele substitui e encapsula operações que antes eram feitas no singleton OS, permitindo múltiplos contextos de exibição em um mesmo sistema operacional. Com o DisplayServer pode-se criar janelas, ajustar suas propriedades (título, tamanho, modo fullscreen/Janela, etc.), bem como obter informações de monitores conectados e suas resoluções. Também gerencia o conteúdo da área de transferência (clipboard) e eventos relacionados a cursor e tela. Embora seja um singleton interno, ao usar Godot via GDScript ou outra linguagem normalmente interagimos indiretamente com DisplayServer através de métodos de mais alto nível, como Window e APIs de tela. No entanto, ele oferece extensões avançadas para plugins ou módulos que precisem de controle direto sobre as janelas do aplicativo.

## Engine
O singleton Engine permite consultar e modificar parâmetros de execução do projeto em tempo real. Isso inclui configurações gerais como taxa de frames por segundo, time scale (escala de tempo global do jogo), limites de frames, uso de múltiplos threads, entre outros. Por exemplo, através de Engine é possível definir o número máximo de threads para processamento paralelo, ativar/desativar monitoramento de profiling, ou pausar o processamento de frames. Em suma, Engine oferece uma visão geral e controle do estado interno do motor de jogo, mas em nível de projeto; muitas de suas funções são utilizadas implicitamente pela execução do jogo e raramente precisam ser chamadas diretamente pelo desenvolvedor.

## Geometry2D
A classe Geometry2D oferece funções utilitárias para operações geométricas em 2D. Ela fornece métodos estáticos para criar formas geométricas, calcular colisões e intersecções, projeções e conversões relacionadas a geometria plana. Por exemplo, inclui funções para encontrar interseções entre segmentos e triângulos, cálculos de barycentric coordinates em triângulos, triangulação de polígonos simples, entre outros. Tais funções são úteis para operações matemáticas comuns em jogos 2D, como detecção de colisões personalizadas ou pré-processamento de geometria.

## Geometry3D
A classe Geometry3D tem papel análogo ao Geometry2D, mas para operações geométricas em 3D. Ela fornece uma coleção de funções auxiliares para criar formas tridimensionais e calcular interseções e outras operações geométricas. Segundo a documentação, “[Geometry3D] fornece um conjunto de funções auxiliares para criar formas geométricas, calcular interseções entre formas, e processar diversas outras operações geométricas em 3D”. Entre seus métodos estão, por exemplo, o cálculo de pontos de malha convexa (`ComputeConvexMeshPoints`), interseção de raios com triângulos (`RayIntersectsTriangle`), interseção de segmentos com esferas/cilindros ou convexos (`SegmentIntersectsSphere`, `SegmentIntersectsCylinder`, `SegmentIntersectsConvex`), e conversão de triângulos em coordenadas baricêntricas (`GetTriangleBarycentricCoords`). Há também funções para construir planos definindo formas básicas (caixa, cilindro, cápsula) e para clipping de polígonos contra planos. Em resumo, Geometry3D é um utilitário abrangente para cálculos geométricos matemáticos em 3D.

## Input
O singleton Input gerencia todos os eventos de entrada do jogo, como teclado, mouse, joysticks e ações definidas no mapa de entrada. Ele fornece métodos para consultar o estado atual de teclas e botões (`is_action_pressed`, `is_key_pressed`, etc.), ler movimento do mouse ou posição de cursores, além de obter listas de eixos de joystick ativos. O Input trabalha em conjunto com o InputMap (mapeamento de ações) para permitir que ações sejam disparadas por combinações de teclas, botões ou eventos específicos. Em GDScript, `Input.get_action_strength("nome_da_acao")`, por exemplo, recupera a força de uma ação virtual. Em suma, Input é a interface principal para lidar com qualquer tipo de entrada de usuário durante a execução.

## InputMap
O InputMap não é um singleton de tempo de execução, mas uma configuração do projeto que define as actions de entrada. Ele armazena o mapeamento de ações (strings) para vários eventos de entrada (teclas, botões, etc.), conforme configurado no editor ou via código (`InputMap.add_action()`, etc.). Em tempo de execução, utiliza-se Input para verificar essas ações. Por exemplo, se definirmos em InputMap uma ação “jump” mapeada para a tecla Espaço, então podemos chamar `Input.is_action_just_pressed("jump")`. O InputMap facilita a abstração de controles, permitindo aos jogadores reconfigurá-los no menu, mantendo o código desacoplado de teclas específicas.

## JSON
A classe JSON permite converter quaisquer dados (Variants) para uma string JSON e vice-versa. Isso é útil para serialização de dados – por exemplo, salvar um dicionário em arquivo ou enviar dados via rede. Ela implementa métodos como `to_json(data)` para converter dados em string JSON e `parse_json(texto)` para transformar JSON em Variants (Array, Dictionary, números, etc.). Dessa forma, é possível salvar estados de jogo em formato JSON ou comunicar-se com serviços web que utilizem JSON, usando a estrutura de dados nativa do Godot.

## Marshalls
A classe Marshalls fornece funções utilitárias de transformação e codificação de dados. Em particular, ela trata da codificação/decodificação em base64 e conversão entre arrays de bytes e tipos do Godot. Por exemplo, existem métodos como `raw_to_base64(Array de bytes)` e `utf8_to_base64(string)` para codificar dados em base64, e os correspondentes `base64_to_raw` e `base64_to_utf8`. Também há funções `variant_to_base64` e `base64_to_variant` para converter Variants arbitrários (estruturas do Godot) em strings base64 e de volta. Assim, Marshalls facilita a serialização compacta de dados binários ou objetos em formatos de texto e vice-versa, o que é útil para comunicação e armazenamento.

## NavigationServer2D
O NavigationServer2D gerencia tudo o que envolve navegação em 2D. Ele lida com mapas de navegação (`NavMap2D`), regiões de navegação (`NavRegion2D`) e agentes de navegação (`NavigationAgent2D`) em cena. Basicamente, ele mantém um navmesh (malha navegável) e permite que agentes calculem caminhos dinâmicos em tempo de execução. Importante notar que não trata de grafos A\* estáticos (como `AStar2D`), sendo usado para navegação runtime baseada em espaço livre. Com o NavigationServer2D, é possível programaticamente configurar áreas navegáveis, obstáculos e consultar caminhos passando por pontos, ou deixar que agentes se movam evitando colisões com obstáculos mapeados no navmesh.

## NavigationServer3D
Análogo ao 2D, o NavigationServer3D gerencia navegação em ambiente tridimensional. Ele administra NavigationMaps (navmeshes 3D), NavigationRegions (volumes navegáveis) e NavigationAgents em 3D, permitindo que agentes (personagens, objetos) obtenham rotas autônomas em espaços 3D usando o navmesh gerado. Assim como em 2D, não substitui grafos A\* estáticos, mas fornece suporte a navegação dinâmica sobre malhas 3D.

## OS
O singleton OS oferece acesso a funcionalidades do sistema operacional hospedeiro. Nele encontram-se configurações gerais de execução do aplicativo, como parâmetros de inicialização, diretórios de usuário, informações da plataforma (nome do SO, modelo de dispositivo, arquitetura), gerenciamento de janelas e controle de tempo de exibição. Por exemplo, OS cuida de abrir janelas, processar eventos globais (como fechar o app), manipular o clipboard, obter informações de data/hora do sistema, além de fornecer funções para lançar arquivos externos ou executar comandos de terminal. Em resumo, OS abstrai operações dependentes de plataforma (sistema de arquivos, OS level, janela principal), servindo como interface entre o Godot e o sistema onde o jogo está rodando.

## Performance
Performance é o singleton usado para monitorar estatísticas de desempenho da engine em tempo real. Ele permite, por exemplo, consultar uso de CPU de cada thread, quantidade de RAM alocada, tempo de frame, quantidade de render calls, entre outras métricas. Essas informações são essenciais para profiling e otimização do jogo. Via Performance, um script pode acessar contadores internos do Godot e medir tempos de execução ou recursos consumidos pelo jogo, ajudando a identificar gargalos.

## PhysicsServer2D
O PhysicsServer2D é o servidor de física 2D de baixo nível. Ele provê toda a simulação física planar: corpos rígidos (`RigidBodies2D`), estáticos, áreas de detecção, colisores, e responsabiliza-se pelo cálculo de colisões e resposta a elas. Com ele é possível criar e configurar formas de colisão, materiais, juntas e efetuar consultas (raycasts) diretamente na cena de física. Em Godot 4, os nós de física (como `RigidBody2D`, `CollisionShape2D`) usam internamente o PhysicsServer2D para executar a simulação. Métodos úteis incluem criação de espaços de colisão separados, configuração de camada/mascara de colisão, e processamento passo-a-passo da simulação.

## PhysicsServer3D
Análogo ao 2D, o PhysicsServer3D gerencia a simulação física em 3D. Ele trata de corpos rígidos 3D (`RigidBodies`, `StaticBodies`, `Area3D`), malhas de colisão, juntas e outras entidades físicas tridimensionais. Fornece métodos para criar formas de colisão (cápsula, caixa, esfera, malha), definir materiais físicos, detectar colisões por raycasting e governar a física step-by-step. O PhysicsServer3D é o núcleo da física 3D do Godot e é utilizado pelos nós de física 3D para processar movimentos, forças e colisões no mundo 3D.

## ProjectSettings
O singleton ProjectSettings permite ler e escrever configurações do projeto em tempo de execução. Ele reflete os parâmetros definidos no editor (Project → Project Settings). Via código, pode-se acessar valores como resolução da tela, nome do projeto, caminho de diretórios, definições de exportação, e quaisquer propriedades expostas no menu de configuração do projeto. Também é possível definir configurações personalizadas (seções definidas pelo usuário) usando `ProjectSettings.set_setting()` e salvá-las em disco. Assim, ProjectSettings é útil para parametrizar o comportamento do jogo sem alterar o código (por exemplo, habilitar debug ou toggles de jogo) e para ler valores globais definidos no editor.

## RenderingServer
O RenderingServer é a API de renderização de baixo nível do Godot. Ele controla diretamente as operações gráficas da engine, como criação de recursos GPU (texturas, mesh, shader, material), submissão de comandos de desenho e gerenciamento de câmeras e viewports. Com o RenderingServer é possível criar cenas inteiramente procedurais definindo meshes, materials e configurações de iluminação programaticamente. Por exemplo, métodos do RenderingServer permitem alocar texturas dinamicamente (`texture_create`), iniciar render targets (texturas renderizáveis), e emitir triângulos diretamente. Normalmente, utilizamos Viewports e nós de malha, mas o RenderingServer expõe o pipeline gráfico subjacente para usos avançados, como renderização customizada em plugins.

## ResourceLoader
O ResourceLoader é responsável por carregar recursos (imagens, cenas, scripts, etc.) do disco em tempo de execução. Ele oferece métodos como `load(path)` que buscam e instanciam recursos de acordo com sua extensão/formatador (por exemplo, .png vira Textura, .tscn vira PackedScene). O ResourceLoader faz cache interno e interpreta formatos de arquivo do Godot. Também é possível carregar recursos de forma assíncrona ou pré-carregar listas de caminhos. Em resumo, ele abstrai o processo de leitura de arquivos do projeto e conversão para objetos do jogo.

## ResourceSaver
O ResourceSaver complementa o ResourceLoader: ele permite salvar recursos em disco. Com métodos como `save(path, resource)`, é possível gravar objetos (Texturas, Meshes, Dicionários, Scenes, etc.) em arquivos no formato do Godot. O ResourceSaver cuida de serializar todas as propriedades do recurso em texto ou binário, de acordo com o formato adequado (por exemplo, .tres, .res). Assim, scripts podem exportar dados do jogo (level editor customizado, configurações salvas) criando recursos no formato padrão do Godot.

## TextServer
O TextServer gerencia operações avançadas de texto e fontes no Godot. Ele controla o layout de texto, fontes dinâmicas e vetoriais (como fontes TrueType), shaping de texto (ligaduras, direção RTL), e medição de largura de linhas. Por exemplo, ao renderizar um Label com texto, o TextServer determina como quebrar linhas, posicionar glifos e lidar com fontes múltiplas (fallback). Ele também trata internacionalização de texto avançada e manipulação de idiomas complexos. Em suma, TextServer é o mecanismo interno por trás de qualquer operação que envolva renderização e processamento de texto.

## Time
O singleton Time oferece funcionalidades relacionadas à medida de tempo do sistema ou do jogo. Entre suas funções estão a obtenção de tempo real do sistema (timestamp), FPS atuais, tempo de execução desde o início do jogo, além de escalas de tempo definidas pelo Engine. Por exemplo, `Time.get_ticks_usec()` retorna microsegundos do relógio interno, e `Time.get_frames_per_second()` informa a taxa de quadros atual. Time também lida com timers globais do engine e permite pauses/continuar time-scaling via Engine.

## TranslationServer
O TranslationServer gerencia a internacionalização (i18n) no Godot. Ele mantém traduções de texto para diferentes idiomas carregadas do projeto. Com ele, é possível definir a língua atual do jogo e obter traduções para chaves de texto usando `TranslationServer.translate(key)`. Ele carrega arquivos .po ou .csv de idiomas, faz o fallback para o idioma padrão se necessário e atualiza automaticamente todos os controles com texto traduzido quando o idioma muda. Em resumo, facilita o suporte multi-idioma ao permitir mapear strings em runtime de acordo com os arquivos de tradução incluídos.

## WorkerThreadPool
O WorkerThreadPool gerencia um conjunto de threads de trabalho no Godot. Ele permite enfileirar tarefas (funções) para serem executadas paralelamente ao loop principal, usando `call()`. Cada tarefa é executada em uma thread separada e, ao concluir, pode retornar um resultado. Isso é útil para operações custosas que poderiam travar o jogo, como processamento de dados em background. O WorkerThreadPool ajusta dinamicamente quantos threads usar, baseando-se no hardware, para balancear desempenho. Desenvolvedores usam este singleton para executar código assíncrono de forma simples, sem gerenciar threads manualmente.

## XRServer
O XRServer é o módulo de realidade estendida (VR/AR) do Godot. Ele gerencia dispositivos XR conectados, como headsets VR, e coordena a renderização estereoscópica e entrada de controles específicos de XR. O XRServer abstrai diferentes runtimes VR (OpenXR, etc.) e fornece informações de câmera separadas para cada olho, além de entrada de trackers (controladores de movimento). Em aplicações de realidade virtual, o XRServer calcula as posições e orientações da cabeça e mãos e aplica correção de distorção para os viewports de cada olho. Ele é utilizado pelos nós de VR/AR do Godot para integrar facilmente qualquer dispositivo compatível com a engine.
