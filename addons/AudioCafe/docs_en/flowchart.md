# AudioCafe Operation Flowchart

This flowchart details the main workflow of the AudioCafe plugin, from activation to the use of generated audio resources.

```mermaid
flowchart TD
    A[Plugin Activated] --> B[AudioPanel instantiated]
    B --> C[AudioConfig created empty]
    C --> D[User configures in AudioPanel]
    D --> D1[Define assets_paths]
    D --> D2[Define dist_paths]
    
    D --> E[User clicks "Update Audio Manifest"]
    
    E --> F[GenerateAudioManifest runs]
    F --> F1[Scans assets_paths]
    F --> F2[Generates Playlists]
    F --> F3[Generates Randomizers]
    F --> F4[Generates Synchronized]
    F --> F5[Collects existing Interactives]
    
    F --> G[Saves Resources to dist]
    G --> G1[.tres files created (playlist, randomizer, synchronized)]
    G --> G2[References saved in AudioManifest]
    
    G --> H[AudioManifest updated]
    H --> I[AudioPanel receives references]
    I --> J[User sees list of Playlists/Randomizers/Synchronized]
    
    J --> K[User accesses via code]
    K --> K1[Direct: @onready var my_playlist = preload("res://dist/ui_click_playlist.tres")]
    K --> K2[Centralized: AudioManifest.randomizer.ui_click]
    
    J --> L[User creates Interactive manually]
    L --> M[Interactive uses already generated resources]
```

## Detailed Flow Description

*   **A. Plugin Activated**: The process begins with the activation of the AudioCafe plugin in the Godot Engine.

*   **B. AudioPanel Instantiated**: The `editor_plugin.gd` instantiates the `AudioPanel` (the plugin's user interface) in the editor.

*   **C. AudioConfig Created/Loaded**: The `AudioPanel` ensures that an instance of `audio_config.tres` exists. If it doesn't, a new one is created with default settings.

*   **D. User Configures in AudioPanel**: The user interacts with the `AudioPanel` interface to define the plugin's settings.
    *   **D1. Define `assets_paths`**: The user specifies the directories where raw audio files (`.ogg`, `.wav`) are located.
    *   **D2. Define `dist_paths`**: The user specifies the directory where generated audio resources (`.tres`) and `audio_manifest.tres` will be saved.

*   **E. User Clicks "Update Audio Manifest"**: After configuring the paths, the user triggers the manifest generation process by clicking the corresponding button in the `AudioPanel`.

*   **F. `GenerateAudioManifest` Runs**: The `generate_audio_manifest.gd` script is executed, starting the processing logic.
    *   **F1. Scans `assets_paths`**: The script traverses the directories defined in `assets_paths` in search of audio files.
    *   **F2. Generates Playlists**: For each group of audio, it generates an `AudioStreamPlaylist.tres` (if the option is enabled).
    *   **F3. Generates Randomizers**: For each group of audio, it generates an `AudioStreamRandomizer.tres` (if the option is enabled).
    *   **F4. Generates Synchronized**: For each group of audio, it generates an `AudioStreamSynchronized.tres` (if the option is enabled).
    *   **F5. Collects existing Interactives**: Scans `dist_path` for `AudioStreamInteractive.tres` resources manually created by the user.

*   **G. Saves Resources to `dist_path`**: The generated audio resources are saved to the distribution directory.
    *   **G1. `.tres` Files Created**: `AudioStreamPlaylist.tres`, `AudioStreamRandomizer.tres`, and `AudioStreamSynchronized.tres` files are created on disk.
    *   **G2. References Saved in AudioManifest**: `audio_manifest.tres` is updated with the paths and UIDs of all generated and collected resources.

*   **H. AudioManifest Updated**: `audio_manifest.tres` now contains the complete catalog of the project's audio.

*   **I. AudioPanel Receives References**: The `AudioPanel` is notified of the generation's completion and reloads `audio_manifest.tres`.

*   **J. User Sees List of Playlists/Randomizers/Synchronized**: The `AudioPanel` displays an updated list of available audio resources, allowing the user to verify the generation result.

*   **K. User Accesses Via Code**: At runtime, the game code can access audio resources.
    *   **K1. Direct Access**: The user can load a `.tres` directly using `preload()` or `load()` if the exact path is known.
    *   **K2. Centralized Access**: The recommended way is to access resources through `audio_manifest.tres` (e.g., `AudioManifest.randomizer.ui_click`), which provides a centralized and organized access point.

*   **L. User Creates Interactive Manually**: The user can create `AudioStreamInteractive.tres` resources manually in the editor.

*   **M. Interactive Uses Already Generated Resources**: These interactive resources can, in turn, reference other audio resources (playlists, randomizers) that were generated by AudioCafe.