# Godot 4.5, tornando sonhos acessíveis

**Por:** Godot contributors
**Data:** 15 de agosto de 2024
**Categoria:** Lançamento

## Godot 4.5 RELEASE

### Tornando sonhos acessíveis

De efeitos alucinantes agora possíveis pelo stencil buffer a descrições acessíveis de seus elementos de GUI que abrem a possibilidade para pessoas com deficiência jogarem seu jogo — temos o orgulho de apresentar a você o Godot 4.5. Com este novo lançamento, fizemos esforços meticulosos para ampliar o que é possível fazer com nosso motor, guiados por nosso objetivo de tornar os jogos e o desenvolvimento de jogos para todos.

### Antes de atualizar

Antes de fazer a transição de seus projetos existentes para o Godot 4.5, leia atentamente nosso guia de migração para saber sobre as mudanças que quebram a compatibilidade.

## Destaques

### Suporte a stencil buffer

Abra seus olhos para novos efeitos

Como "perfuramos um buraco" visualmente naquela parede para espiar o jogador do outro lado? Agora você pode fazer isso com stencil buffers! Imagine uma esfera invisível que envolve nosso personagem. Mesmo que a geometria não esteja sendo renderizada na tela, inserimos sua forma no stencil buffer. Em seguida, fazemos com que nossos shaders de parede renderizem apenas se o pixel de destino não estiver coberto pelo stencil. Voilà.

Um stencil buffer é um buffer especial no qual as malhas podem escrever para comparação posterior. É semelhante ao depth buffer existente, exceto que valores arbitrários podem ser escritos e você tem mais controle sobre o que faz com as comparações.

### Suporte a leitor de tela

Mostre, não conte

Um recurso frequentemente esquecido que é obrigatório em softwares de computador é o suporte a leitor de tela. Esses leitores são uma ferramenta essencial para pessoas com deficiência visual, analfabetas ou com dificuldades de aprendizado. Graças ao AccessKit, adicionamos suporte a leitor de tela aos nós Control, e também adicionamos vinculações de leitor de tela para personalizar o comportamento de qualquer tipo de Nó.

Como este recurso é bastante novo, observe que sua integração ainda está em fase experimental. E o suporte a leitor de tela para o próprio Editor Godot ainda não está completo — ele é implementado apenas para o Gerenciador de Projetos, nós de UI padrão e o inspetor. Espere acompanhamentos em futuras atualizações.

### Rastreamento de script e loggers personalizados

Descendo a toca do coelho

O rastreamento de script fornece aos desenvolvedores os detalhes exatos sobre onde um problema ocorreu no código. Mesmo em builds de "Release". Loggers personalizados permitem que os desenvolvedores interceptem mensagens de log e erros. Isso torna possível criar uma ferramenta para relatar bugs dentro do seu jogo.

Desenvolvedores e jogadores agora poderão relatar problemas contendo informações mais precisas de sua origem.

Certifique-se de que a configuração do projeto Debug > Settings > GDScript > Always Track Call Stacks esteja ativada.

### Shader baker

Pré-aqueça o forno

Qualquer um que jogue jogos modernos, especialmente no PC, já teve a experiência de esperar pela compilação de shaders. Geralmente, isso aparece de duas formas: ou o jogo faz você esperar quando é iniciado pela primeira vez, ou faz você esperar bem no meio da ação.

Isso ocorre porque os shaders são pequenos programas para sua GPU que desenham a cena atual. E eles precisam ser compilados para serem usados.

Embora a compilação de pipeline ainda seja inevitável e um requisito, o Godot agora oferece uma maneira de fazer tudo o que pode ser feito pelo editor com antecedência, reduzindo muito esses tempos de espera.

Onde os ubershaders foram um grande passo para otimizar a compilação de pipeline e eliminar travamentos de compilação, o shader baker aborda os longos tempos de inicialização.

Quando ativado nas configurações de exportação, o shader baker escaneará recursos e cenas em busca de shaders e os pré-compilará no formato correto usado pelo driver na plataforma de destino.

Ao direcionar dispositivos Apple e Windows, usando Metal e D3D12, respectivamente, vimos uma diminuição de 20x nos tempos de carregamento para nossa demonstração de TPS. Fale sobre velocidade!

### Pré-visualização ao vivo de internacionalização

Este novo recurso é fundamental para o nosso ideal de tornar os jogos acessíveis a todos.

A partir de agora, os desenvolvedores poderão pré-visualizar traduções diretamente da viewport do editor. Isso aliviará o fardo de testar a GUI em vários idiomas.

Como sua nova UI reage ao estar em francês ou holandês? Ou como ela se parece em chinês simplificado ou tradicional, ou mesmo em hindi?

A direção do layout segue apenas o local principal atualmente. Estamos trabalhando para corrigir esse problema.

## Geral

### 2D

#### Física de tilemap em chunks

Fusão... HA!

Desde que os tilemaps 2D foram implementados pela primeira vez, a física sempre dependeu do conceito de "um tile, um corpo". Embora isso funcione para a maioria dos jogos, pode facilmente levar a problemas de desempenho em cenas 2D que dependem da física, pois o número de corpos é extremamente ineficiente.

O sistema foi retrabalhado do zero. Agora, a física do TileMapLayer mescla formas de célula em formas de colisão maiores sempre que possível.

### Núcleo

#### Duplicar com facilidade e resultados esperados

Tão profundo quanto você desejar

Por muito tempo, embora Resource.duplicate() tenha um parâmetro deep, as pessoas perceberam que configurá-lo como true nem sempre funciona de forma confiável e previsível. Notavelmente, ele não duplica sub-recursos armazenados em propriedades Array ou Dictionary. O mesmo acontece com Array.duplicate() e Dictionary.duplicate().

Os novos métodos duplicate_deep() para essas classes agora dão aos usuários controle total sobre o que é duplicado ou não.

Este novo recurso é o resultado de uma revisão da lógica de duplicação para arrays, dicionários e recursos. Para os desenvolvedores, garantimos manter o que estava funcionando e consistente intacto. Se precisar de mais detalhes, sinta-se à vontade para consultar nossa nova documentação exaustiva sobre a especificação de duplicação.

#### Adapte o motor aos seus projetos com essas melhorias de perfil de build

Desde o Godot 4.0, os usuários podem abrir Project > Customize Engine Build Configuration para acessar a janela "Edit Build Configuration Profile". Este utilitário ajuda a selecionar e até mesmo detectar quais classes (ou seja, quais Nós, Recursos e servidores) são realmente necessárias para o projeto atualmente aberto. A ideia é que, ao reduzir os recursos apenas para os realmente necessários, os usuários podem construir seu próprio modelo Godot que se adapta perfeitamente ao seu jogo.

O 4.5 expande o que é detectado. Não apenas detecta classes, mas também pode definir opções de build corretas. Também leva em consideração quais classes são usadas pelas GDExtensions do projeto.

Você pode ler mais sobre isso em nossa documentação.

### Editor

#### Alternar mudo do jogo

Depurar pode ser tedioso, especialmente se expõe o desenvolvedor à mesma música repetidamente. Um poderia desligar os alto-falantes completamente, mas isso não é muito prático, não é?

Para manter a sanidade de todos, introduzimos o novo botão de alternar mudo do jogo, localizado na visualização do Jogo.

Que seus ouvidos desfrutem dessas novas oportunidades de quietude.

#### Arrastar e soltar recursos em scripts para pré-carregar por UID em vez de por caminho

Com o Godot 4.4, estendemos o suporte a UID para mais tipos de recursos para evitar caminhos quebrados.

Os scripts agora podem aproveitar isso pré-carregando recursos por meio de seu UID. Basta soltar o recurso enquanto mantém Ctrl (Cmd no macOS).

Ao usar UIDs em vez de caminhos para pré-carregamento, seus scripts serão mais resilientes, onde quer que os recursos que você está pré-carregando estejam em seu projeto.

#### Permitir a seleção de vários nós remotos em tempo de execução

A nova janela de jogo incorporada introduzida no 4.4 destacou um problema que o editor tinha há muitos anos: a lista de nós remotos não suportava a seleção de mais de um item.

Isso agora é coisa do passado. Os desenvolvedores agora podem selecionar vários nós e até mesmo editar propriedades comuns.

#### O idioma do editor pode ser alterado sob demanda

Alterar o idioma do editor não requer mais uma reinicialização do editor.

Este recurso pode ser bastante útil para desenvolvedores de plugins de editor que testam suas traduções.

Para todos os outros, agora você pode testar o editor em todos os idiomas que ele suporta!

#### Seções do inspetor alternáveis

Vai Vai Seção do Inspetor!

Como uma atualização da experiência do usuário, substituímos a propriedade ativada dentro dos grupos por uma caixa de seleção intuitiva ao lado do nome da seção. Agora você pode ver facilmente quais seções estão ativadas, mesmo as recolhidas.

Os desenvolvedores de plugins podem usar esse recurso em seus projetos usando o novo PROPERTY_HINT_GROUP_ENABLE.

#### Exportar variáveis como Variant

Com esta nova atualização, agora é possível exportar variáveis como Variant.

Anteriormente, uma variável só podia ser exportada como Variant se tivesse um valor inicializado. Além disso, o editor se ateria ao tipo real do referido valor, impossibilitando a alteração do valor para outro tipo Variant suportado, como String ou Color.

Agora, se a variável exportada for do tipo Variant, o editor reage de acordo, permitindo que o usuário atribua qualquer valor Variant compatível. Há até um seletor de tipo elegante que altera o widget de entrada de acordo.

#### Seletor de cores de script

Nem todo mundo consegue ler cores. Então adicionamos uma pequena pré-visualização de cor ao lado de cada valor Color.

Até levamos a ideia adiante: se você clicar nesse ícone de pré-visualização, poderá editar o valor na hora usando um seletor de cores.

#### Executar EditorScripts usando a paleta de comandos

Qualquer arquivo EditorScript nomeado em seu projeto agora aparece na paleta de comandos, tornando muito mais fácil executar comandos de projeto específicos.

#### Opção "Colar como único"

Ao copiar e colar um recurso em um slot do inspetor do editor, ele geralmente cola uma referência aos recursos copiados. Se você quisesse uma cópia única, teria que clicar manualmente em "Tornar Único" depois.

Agora, a nova opção "Colar como Único", disponível no menu suspenso do seletor de recursos, torna a operação muito menos tediosa.

#### Duplicar projetos diretamente do Gerenciador de Projetos

Agora há um botão "Duplicar" dedicado no Gerenciador de Projetos, facilitando o backup de um projeto existente ou a criação de um novo.

Também pensamos que seria uma ótima ferramenta para evitar perdas se você atualizar a versão do motor durante o desenvolvimento. Se detectarmos que ocorreriam mudanças irreversíveis devido à atualização, perguntaremos se você deseja fazer backup do seu projeto primeiro.

#### Anexar fonte de sinal automaticamente

Isso realmente ajudará a desvincular sinais de sua fonte e tornará a reutilização de código muito mais fácil.

Ao conectar sinais no editor, você notará uma nova opção "Anexar Fonte" nas configurações avançadas. Se esta caixa de seleção estiver ativada, o objeto de origem será anexado logo após os argumentos originais do sinal.

#### Atualizações de qualidade de vida do Animation Player

O Animation Player recebeu um amor muito necessário!

Você pode usar a caixa de seleção para selecionar e dimensionar pontos do editor Bézier. Agora é muito fácil realizar alterações em lote. Ao criar pontos Bézier, você pode auto-tangenciar novos pontos de forma equilibrada ou espelhada. Você pode classificar as animações do Animation Player em ordem alfabética. Também é possível filtrar animações por seus nomes!

#### Ícones com reconhecimento de DPI

Os ícones agora parecem mais nítidos do que nunca

Os controles padrão e a UI do editor tendiam a parecer borrados em telas HiDPI. Retrabalhamos a renderização desses componentes para que pareçam nítidos em todas as telas.

### GUI

#### Conteúdo em cascata facilmente com FoldableContainer

O novo nó FoldableContainer adiciona uma maneira fácil de exibir muitos detalhes a critério do usuário, em uma visualização "sanfona".

Ele até suporta agrupamento, garantindo que apenas um container dobrável esteja aberto por vez.

#### Efeitos empilhados de Label

Estilize labels o quanto quiser com o Godot 4.5. Adicionamos suporte para camadas empilhadas de efeitos; sem soluções alternativas complicadas.

Você quer que ele seja delineado com sombras complexas? Feito.

#### Lide com uma GUI complexa facilmente com overrides recursivos

GUI pegajosa nunca mais

Agora é possível alterar o comportamento do mouse e do foco de um nó Control recursivamente. Isso ajuda muito a criar GUIs complexas sem suar a camisa.

Aqui está um exemplo: digamos que você crie uma tela de inventário para o seu jogo. À esquerda, há uma grade exibindo o que o herói está carregando. À direita, mostra uma visualização detalhada sobre o item selecionado à esquerda; uma exibição rotacionável do item em 3D para examinar cada detalhe, uma seção contendo uma descrição rolável, uma caixa contendo estatísticas e modificadores (com hiperlinks para termos técnicos) e uma lista de botões representando ações que são possíveis de fazer com ele.

Agora, o problema é que a visualização à direita depende de um item ser selecionado à esquerda. O usuário não deve ser capaz de interagir com a visualização de detalhes até que isso aconteça.

Ao alterar Control.focus_behavior_recursive e Control.mouse_behavior_recursive do container de visualização detalhada para seu valor desativado até que um item seja selecionado, os eventos de foco e mouse serão desativados para cada filho. Você não precisa mais recorrer a mensagens complexas para gerenciar o comportamento dos grupos de Control.

### Documentação

#### Adicionado qualificador "required"

Mas você deve!

Quando estendidas, algumas classes precisam que alguns métodos virtuais sejam sobrescritos para funcionar. Mas nem sempre era óbvio na documentação.

Isso não será um problema daqui para frente, pois agora o novo qualificador required virá logo após virtual, onde aplicável.

## Plataformas

### Android

#### UI do editor adaptada para usuários não-desktop

Usuários de teclado virtual podem atestar a natureza orientada para desktop da UI do editor. Ações comuns – como desfazer e salvar – são tediosas de executar, pois exigem abrir a barra de menu cada vez para encontrar a ação.

Com o novo TouchActionsPanel, usuários de tablet e telefone agora têm acesso direto a botões de ações comuns.

Este recurso é atualmente apenas para Android, mas pretendemos portá-lo para outras plataformas o mais rápido possível.

#### Suporte para dispositivos com páginas de 16KB

Os computadores têm alguns truques na manga para lidar com gigabytes de memória. Um desses truques é "paginar" a memória em blocos discretos, para que o sistema possa pular rapidamente para ela ao procurar um endereço específico.

As páginas podem ter vários tamanhos, dependendo da plataforma. Desde sua criação, o Android suportava apenas páginas de 4KB, mas a equipe do Android anunciou recentemente a compatibilidade com páginas de 16KB a partir do Android 15. Os desenvolvedores devem observar, no entanto, que a partir de 1º de novembro de 2025, o Google Play exigirá que todos os novos aplicativos enviados para o Android 15 suportem páginas de 16KB.

Felizmente, nós te protegemos; o Godot 4.5 suporta esse recurso de fábrica.

#### Suporte de ponta a ponta

Normalmente, os desenvolvedores tinham duas opções para exibir conteúdo na tela: ou seu aplicativo deixava as áreas superior e inferior para as barras de status e navegação do sistema, ou seu aplicativo podia ir para tela cheia, reivindicando todo o espaço sem exibir essas barras.

A partir de agora, há uma nova opção de exportação. O Android tem um recurso chamado exibição "de ponta a ponta". Ele oferece aos desenvolvedores a capacidade de desenhar em toda a tela, como se estivesse em tela cheia, mas com sobreposições da barra do sistema.

Isso dá ao seu jogo uma aparência mais moderna que combina com o estilo de design do Android.

#### Suporte a feed de câmera

O Godot agora suporta o acesso ao feed de câmera bruto do dispositivo no Android.

Isso permite que os desenvolvedores acessem a entrada da câmera ao vivo e processem os dados para qualquer finalidade que desejarem. De filtros de rosto fofos a AR, as possibilidades com esse recurso são infinitas!

#### Faça lightmaps e UV unwrap em movimento!

Fazer lightmaps e unwrap de UVs com o Godot Editor não se limita mais apenas a sistemas operacionais de desktop. Agora você pode fazer isso em seu telefone ou tablet.

Se fazer jogos em dispositivos móveis agora é totalmente possível, o que o impede de criar o próximo blockbuster?

### Linux

#### Suporte nativo a sub-janelas Wayland

Uma janela vale mais que mil palavras

O suporte a sub-janelas significa que o Godot agora pode gerar novas janelas independentes ao ser executado no Wayland nativamente.

Este também foi um obstáculo importante (e não pequeno) a ser superado para alcançar a incorporação de jogos no futuro, que já está sendo trabalhado neste PR.

### Apple

#### Suporte a incorporação de jogos no macOS

Usuários do Godot no macOS agora podem desfrutar da janela de jogo incorporada introduzida para algumas plataformas no 4.4.

#### Exportar para visionOS

Agora você pode exportar para a plataforma XR da Apple, visionOS, tornando os projetos Godot compatíveis com o Apple Vision Pro.

O Godot 4.5 marca o primeiro passo da integração nativa do visionOS. Para isso, gostaríamos de agradecer à equipe de engenharia do visionOS da Apple por suas contribuições adicionando suporte para seu sistema operacional ao Godot Engine.

Isso é um grande negócio: o visionOS é a primeira plataforma suportada nativamente pelo Godot desde que o projeto foi de código aberto!

Atualmente, só é possível exportar um projeto como um "aplicativo em janela". Seu jogo aparecerá como uma janela, flutuando no espaço 3D do usuário. Esperamos suportar experiências totalmente imersivas no futuro.

### Windows

#### Modificar metadados sem rcedit

Adeus, rcedit!

Os metadados de arquivos .exe do Windows (como um ícone personalizado, o nome do produto e as informações da empresa) são armazenados internamente como "recursos".

Por anos, para modificar esses recursos, o exportador do Windows precisava acessar um programa externo do Windows: rcedit. Isso tornava muito difícil exportar para Windows em uma máquina não-Windows.

Mas agora, o exportador do Windows sabe como lidar com os recursos nativamente, então você pode editar metadados de exportação do Windows sem problemas, em todas as plataformas.

### Web

#### Suporte a WebAssembly SIMD

Aumento de desempenho gratuito

Há cerca de dois anos, todos os principais navegadores suportam WASM (WebAssembly) SIMD. SIMD significa "Single Instruction, Multiple Data" e é uma tecnologia que permite que as CPUs façam algumas computações paralelas, muitas vezes acelerando o programa como um todo.

A partir do 4.5, você pode esperar que seus jogos Web rodem um pouco mais suavemente, sem ter que fazer nada – especialmente quando as coisas ficam caóticas para sua CPU. Não é uma bala de prata para jogos mal otimizados, mas ajudará mesmo assim.

## Scripting

### C#/.NET

#### Carregando assemblies .NET diretamente de APKs Android

Direto da fonte

Assemblies são os blocos de construção de qualquer aplicativo C#/.NET, pois fornecem tipos e recursos para diferentes funcionalidades. As funcionalidades variam de utilitários de E/S do sistema à lógica do seu próprio jogo.

No passado, para Android, extraíamos os assemblies .NET do APK exportado e os armazenávamos em cache. Embora isso funcione bem em outras plataformas, causou problemas no Android, como assemblies desatualizados ou erros de permissão.

Agora carregamos esses assemblies diretamente do APK, o que resolve todos esses problemas.

### GDScript

#### Introduzindo argumentos variádicos

As funções GDScript agora podem aceitar um número arbitrário de parâmetros!

```gdscript
extends Node
func sum(first_number: float, ...numbers: Array) -> float:
    var total := first_number
    for number in numbers:
        total += number
    return total

func _ready() -> void:
    sum(1) # 1.0
    sum(1, 2, 3) # 6.0
    sum(1, 2, 3, 4, 5) # 15.0
```

#### Classes e métodos abstratos

Você não pode tocar nisso

Agora você pode declarar classes GDScript como abstratas. Declarar uma classe abstrata significa que a classe não deve ser instanciada diretamente. Isso significa que você pode impedir instâncias de uma classe, digamos, Animal, que não tem nenhum propósito por si só, a não ser ser estendida por classes "concretas" como Cat e Dog.

Classes abstratas também podem ter métodos abstratos. Isso significa que o método deve ser implementado em qualquer classe que a estenda.

`animal.gd`
```gdscript
@abstract
class_name Animal extends Node
@abstract
func cry() -> void
```

`cat.gd`
```gdscript
class_name Cat extends Animal
func cry() -> void # Deve ser implementado, caso contrário, um erro será lançado.
    print("Meow!")
```

### GDExtension

#### Callbacks do loop principal

Os plugins GDExtension às vezes precisam executar código em momentos específicos do motor. Por exemplo, havia muitos problemas para acessar os singletons do motor a partir do GDExtension, já que não havia uma maneira simples de saber quando o motor havia iniciado ou desligado.

A partir de agora, os desenvolvedores podem registrar callbacks do loop principal diretamente do GDExtension, como inicialização e desligamento.

Este novo recurso é o resultado de nossos esforços contínuos para trazer C#/.NET para GDExtension, pois a porta precisava registrar um callback de quadro.

## Sistemas

### Animação

#### Vincular ossos a outros ossos com BoneConstraint3D

Ei, eu ouvi dizer que você gosta de restrições, então coloquei restrições em seus ossos para que você possa mover ossos quando os ossos se movem.

Com BoneConstraint3D e os novos AimModifier3D, CopyTransformModifier3D e ConvertTransformModifier3D, agora é possível vincular ossos a outros ossos. Isso pode permitir movimentos e poses mais naturais.

Este recurso é realmente útil para lidar com avatares de VR e metaverso.

### Importação

#### Reintroduzindo a edição em lote de ativos

Se não está quebrado...

Quer alterar rapidamente a mesma configuração de importação para vários arquivos de recurso?

Reintroduzimos opções no dock de Importação para edição em lote de ativos. Agora, ao selecionar arquivos no dock do FileSystem, o dock de Importação permitirá que você selecione quais propriedades deseja editar. Com um único clique no botão "Reimportar", suas novas configurações de importação serão aplicadas a todos os arquivos selecionados simultaneamente.

### Entrada

#### Driver de entrada de gamepad SDL3

Gamepads em abundância!

Gamepads são um dado adquirido nos jogos de PC modernos. Os usuários esperam que seu gamepad simplesmente conecte e funcione. Não apenas isso, mas para oferecer experiências únicas, alguns gamepads estão introduzindo novos recursos; de gatilhos adaptativos e feedback tátil avançado, a microfones e controles de movimento.

Com o tempo, problemas se acumularam em nossa implementação de driver de gamepad e recursos ausentes começaram a surgir. Estávamos enfrentando uma montanha cada vez maior.

É por isso que voltamos nossa atenção para o projeto SDL. SDL é uma biblioteca multiplataforma bem estabelecida e madura que lida com áudio, teclado, mouse, joystick e gráficos. Determinamos que agora é um saldo positivo delegar a responsabilidade pelo tratamento do gamepad a ela.

Embora essa mudança não traga por si só novos recursos, espere que correções de bugs e novos recursos cheguem um pouco mais rápido a partir de agora.

### Navegação

#### Servidor de navegação 2D dedicado

Desde sua introdução no Godot 4.0, usuários e nós de navegação interagiram com o NavigationServer2D para todas as suas necessidades de pathfinding 2D. Mas e se eu dissesse que o NavigationServer2D estava escondendo algo?

Anteriormente, o NavigationServer2D era efetivamente um proxy para o NavigationServer3D; ele usava a lógica de navegação 3D, mas com tudo restrito a dois eixos.

No entanto, isso tinha uma ressalva importante. Jogos 2D puros usando navegação exigiam um modelo de exportação que tivesse suporte 3D. Isso obviamente aumentaria o tamanho final de exportação do jogo.

Agora finalmente conseguimos criar um servidor de navegação 2D dedicado. Os usuários poderão ajustar seus servidores de navegação 2D e 3D independentemente.

#### Processar regiões de navegação assincronamente

O thread principal de um programa de computador é como um líder de projeto. Se o líder de projeto lida com muitas tarefas e não delega o suficiente, isso pode afetar o desempenho geral da equipe.

Ativar iterações assíncronas pede aos servidores de navegação para delegar o processo de navegação a um thread em segundo plano, o que pode melhorar o desempenho geral da navegação.

### Física

#### Interpolação de física 3D do SceneTree

Frames crescem em árvores agora

Transplantamos (ou deveríamos dizer "enxertamos"?) a interpolação de física 3D para o SceneTree. Introduzida no Godot 4.4, a interpolação de física 3D é o conceito de fazer com que o movimento baseado em física pareça fluido, mesmo que esteja rodando mais lento que a taxa de quadros do processo.

Anteriormente, implementamos esse recurso no RenderingServer, pois o recurso está principalmente ligado ao desenho de estados intermediários e não exigia a alteração do código que lida com Nós. Infelizmente, isso causou alguns problemas. Ou seja, na prática, os nós embutidos do Godot — e os nós personalizados — frequentemente dependem das transformações do Node3D para seu comportamento. Devido a razões técnicas e relacionadas ao desempenho, provou ser impossível consultar o RenderingServer para transformações interpoladas. Tivemos que mover tudo para o SceneTree para 3D, onde os nós residem.

Isso não apenas corrigiu vários problemas, mas também torna tudo conceitualmente mais fácil para usuários e mantenedores.

Não se preocupe: o que é incrível é o fato de que mantivemos a API de usuário existente, mesmo que muito tenha mudado sob o capô. Portanto, essa mudança não deve quebrar seu projeto!

### Renderização

#### Oclusão especular da luz ambiente

Realismo adicionado por pouco

Já se perguntou por que alguns objetos brilhavam estranhamente como se estivessem iluminados em uma área ocluída onde não deveriam? Por exemplo, um obstáculo comum para os usuários é ver a luz do céu ser refletida nas rachaduras entre os tijolos em uma parede de tijolos.

Isso ocorre porque o cálculo da luz refletida em uma superfície não levava em consideração a oclusão ambiente.

Felizmente, nosso renderizador agora tem uma opção barata para oclusão especular que deve corrigir esse problema.

Para projetos existentes onde isso pode quebrar a aparência, não se preocupe. Uma opção está disponível nas configurações do projeto.

#### Suporte a mapas normais curvos

Apresentando o normalbender

Na gíria de renderização, uma normal é um vetor 3D que é perpendicular a uma superfície. Um mapa normal é uma textura onde cada pixel de it representa uma normal — usando a intensidade vermelha, verde e azul como os valores do eixo do vetor.

Mapas normais são frequentemente usados em modelos para adicionar detalhes de superfície sem ter que tornar as malhas super detalhadas. Se o mapa normal descreve uma protuberância, o sistema de iluminação fará com que pareça haver uma, mesmo que o polígono subjacente seja plano.

Mapas normais curvos são semelhantes, pois são texturas que representam vetores 3D, cada um apontando para algo. As normais são consideradas "curvas" porque, em vez de serem perpendiculares à superfície, elas realmente apontam para a direção de menor oclusão — ou seja, a direção com a menor quantidade de coisas bloqueando a luz incidente. Por exemplo, se um mapa normal curvo teórico fosse criado a partir do interior de uma caverna, cada vetor apontaria para a abertura.

O que isso significa? Por que devemos nos preocupar com a direção de menor oclusão?

Esta informação é extremamente valiosa para o renderizador. É usada para aprimorar ainda mais a oclusão especular (escurecer áreas que não deveriam receber muitos reflexos) e a iluminação indireta (fornecer reflexos mais precisos).

#### Suporte a SMAA 1x

Às vezes, os addons são tão bons que são promovidos e incluídos diretamente no motor. Isso acabou de acontecer com o addon Godot-SMAA.

Subpixel Morphological Antialiasing (SMAA) é uma solução moderna de anti-aliasing baseada em pós-processamento, para se livrar daquelas serrilhados irritantes. Ele fornece um AA mais nítido do que o FXAA, com a desvantagem de ser mais intensivo em recursos.

Este é um passo em nossa busca para melhorar os efeitos de pós-processamento embutidos no Godot!

#### Renderizador móvel agora usando formato de ponto flutuante de meia precisão explicitamente

Mesmo o menor float pode mudar o curso do renderizador móvel

Se um computador só consegue entender 0s e 1s, como ele pode calcular números não inteiros? É aí que entra a aritmética de ponto flutuante. É um método para representar esses tipos de números em binário.

Uma GPU móvel não só precisa processar pixels o mais rápido possível, mas precisa fazê-lo de forma eficiente em termos de energia. Recentemente, a indústria percebeu que mesmo o formato padrão de ponto flutuante de precisão simples (F32) às vezes pode ser excessivo em termos de tamanho e poder de processamento, mesmo para fins de renderização.

Com esta nova atualização, o renderizador móvel agora solicita explicitamente o formato de ponto flutuante de meia precisão (F16) se o hardware o suportar — a maioria dos dispositivos comumente usados deve, especialmente se forem novos. Se sim, os jogos agora devem ver o desempenho de renderização aumentar, rodar mais suavemente no geral (melhor cadência de quadros) e exigir menos uso de energia.

### XR

#### Suporte a backend D3D12 OpenXR

Adicionamos um novo backend para OpenXR! Agora você pode renderizar seus projetos XR usando D3D12 em plataformas Microsoft.

#### Renderização foveada no Vulkan Mobile

Para obter ótimos visuais em um headset VR, um pouco de trapaça é frequentemente necessário. O olho humano vê mais detalhes no centro do seu olhar e menos ao redor da sua visão periférica. Então, por que deveríamos renderizar as bordas da viewport em resolução total?

Isso é chamado de "renderização foveada" e é algo que o Godot suporta com OpenGL ou Vulkan no desktop (via extensão "Fragement Shading Rate") há muito tempo.

No entanto, agora foi adicionado suporte para a extensão Vulkan "Fragment Density Map", que também permite isso no renderizador Vulkan Mobile, tornando-o uma opção mais viável para headsets VR autônomos.

#### Modelos de renderização OpenXR

Adicionamos suporte para as extensões XR_EXT_render_model e XR_EXT_interaction_render_model introduzidas no OpenXR.

Essas extensões, quando ativadas e suportadas, dão a um aplicativo acesso a modelos totalmente animados dos controladores atualmente mantidos pelos usuários. Isso significa que os usuários do Meta Quest 3S e Pico 4 Ultra verão seus respectivos controladores em suas mãos sem esforço extra do desenvolvedor.

Para usar esse recurso em seu jogo, você precisa adicionar OpenXRRenderModels como um nó filho do nó XROrigin3D. Para mais informações, consulte a documentação.

#### Application SpaceWarp, a postos

Os recursos de headset móvel podem ser escassos, por isso é importante saber como otimizar o orçamento de computação. Porque o XR requer uma alta taxa de atualização, os desenvolvedores ficam com um tempo limitado para renderizar. Mas e se pudéssemos usar a síntese de quadros a nosso favor? Poderíamos renderizar em meia taxa enquanto a GPU sintetiza o próximo quadro, mantendo a taxa de quadros alvo como um todo, enquanto nos damos efetivamente muito mais tempo.

É exatamente isso que o Application SpaceWarp da Meta faz nos headsets Meta e Pico. Agora suportamos essa tecnologia com o lançamento mais recente do nosso plugin de fornecedores OpenXR, graças à implementação de vetores de movimento no renderizador móvel.

Como o OpenXR acaba de lançar a extensão de síntese de quadros de vários fornecedores, esperamos suporte para mais headsets no futuro.

## Agradecimentos Especiais

### Autores da versão

Trabalho em equipe faz o sonho acontecer

Aqui você pode ver todos os colaboradores que tiveram PRs mesclados neste lançamento. Os nomes são ordenados alfabeticamente e dimensionados de acordo com o número de contribuições.

Agradecimentos especiais a todas as equipes do motor que colaboraram neste lançamento, especialmente porque os commits para outros repositórios relacionados (documentação, godot-cpp, etc.) não aparecem neste gráfico.

### Créditos da página de lançamento

Desenvolvimento web e textos por Adam Scott. Textos revisados por A Thousand Ships, John Veness e Malcolm Anderson. Conteúdo de mídia por Adam Scott. Conteúdo de mídia adicional por criadores de conteúdo marcados. Miniatura de lançamento por Tibo. Plano de fundo do cabeçalho por Lander Van Regenmortel. Modelo de design por Luis Carli.
